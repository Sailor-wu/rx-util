(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.rx = {}));
}(this, function (exports) { 'use strict';

  /**
   * 在浏览器上下载二进制资源
   * @param {Blob} blob 要下载的二进制资源
   * @param {String} filename 文件名
   */
  function download(blob) {
    var filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown';
    // 创建隐藏的可下载链接
    var eleLink = document.createElement('a');
    eleLink.download = filename;
    eleLink.style.display = 'none'; // 为 link 赋值

    eleLink.href = URL.createObjectURL(blob); // 触发点击

    document.body.appendChild(eleLink);
    eleLink.click(); // 然后移除

    document.body.removeChild(eleLink);
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] =
      GeneratorFunction.displayName = "GeneratorFunction";

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        prototype[method] = function(arg) {
          return this._invoke(method, arg);
        };
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList)
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    Gp[toStringTagSymbol] = "Generator";

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var regenerator = runtime_1;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var asyncToGenerator = _asyncToGenerator;

  /**
   * 在浏览器上下载文本内容
   * @param {String} str 字符串内容
   * @param {String} [filename='unknown.txt'] 下载文件名，没有则默认为链接中的文件名
   */

  function downloadString(_x) {
    return _downloadString.apply(this, arguments);
  }

  function _downloadString() {
    _downloadString = asyncToGenerator(
    /*#__PURE__*/
    regenerator.mark(function _callee(str) {
      var filename,
          blob,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              filename = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'unknown.txt';
              blob = new Blob([str], {
                type: 'text/plain'
              });
              download(blob, filename);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _downloadString.apply(this, arguments);
  }

  /**
   * 根据 url 下载二进制资源
   * @param {String} url 下载请求信息
   * @param {String} [filename] 下载文件名，没有则默认为链接中的文件名
   */

  function downloadUrl(_x) {
    return _downloadUrl.apply(this, arguments);
  }

  function _downloadUrl() {
    _downloadUrl = asyncToGenerator(
    /*#__PURE__*/
    regenerator.mark(function _callee(url) {
      var filename,
          res,
          blob,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              filename = _args.length > 1 && _args[1] !== undefined ? _args[1] : url.substr(url.lastIndexOf('/'));
              _context.prev = 1;
              _context.next = 4;
              return fetch(url);

            case 4:
              res = _context.sent;
              _context.next = 7;
              return res.blob();

            case 7:
              blob = _context.sent;
              download(blob, filename);
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);
              return _context.abrupt("return", console.log('下载出错了 ', _context.t0));

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 11]]);
    }));
    return _downloadUrl.apply(this, arguments);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  var arrayWithHoles = _arrayWithHoles;

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  var iterableToArrayLimit = _iterableToArrayLimit;

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var nonIterableRest = _nonIterableRest;

  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
  }

  var slicedToArray = _slicedToArray;

  /**
   * 获取 cookie 键值映射 Map
   * @returns {Map.<String,String>} cookie 键值映射 Map
   */
  function getCookies() {
    return document.cookie.split(';').map(function (str) {
      return str.split('=');
    }).map(function (arr) {
      return [arr[0].trim(), arr[1].trim()];
    }).reduce(function (res, _ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return res.set(k, v);
    }, new Map());
  }

  /**
   * 将 url 中的内容加载到元素上
   * 注：domSelector 必须有 src 属性用以将加载完成的资源赋值给其，加载默认是异步的
   * @param {RequestInfo} url url 资源
   * @param {HTMLImageElement | HTMLAudioElement | HTMLVideoElement | HTMLTrackElement | HTMLScriptElement} dom dom 元素
   * @param {RequestInit} [init] 初始化参数, 实为 fetch() 的参数以及一些自定义的参数，默认 {}
   * 关于 fetch 具体可以参考 <https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch>
   */
  function loadResource(_x, _x2) {
    return _loadResource.apply(this, arguments);
  }

  function _loadResource() {
    _loadResource = asyncToGenerator(
    /*#__PURE__*/
    regenerator.mark(function _callee(url, dom) {
      var init,
          res,
          blob,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              init = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              _context.next = 3;
              return fetch(url, init);

            case 3:
              res = _context.sent;
              _context.next = 6;
              return res.blob();

            case 6:
              blob = _context.sent;
              // 生成一个本地的 url 并赋值给 src 属性
              dom.src = window.URL.createObjectURL(blob);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _loadResource.apply(this, arguments);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  /**
   * Url 对象
   * @class UrlObject
   */
  var UrlObject =
  /**
   * 构造函数
   * @param {Object} option 可选项
   * @param {String} [option.href=''] 不包含网站域名的链接
   * @param {String} [option.website=''] URL 站点
   * @param {String} [option.protocol=''] 协议
   * @param {String} [option.domain=''] 域名
   * @param {String} [option.accessPath=''] 绝对路径,不包含参数
   * @param {Object} [option.params={}] 参数列表,
   * @param {String} [option.url=''] 原 url 链接
   * @param {Number} [option.port=0] 端口号
   */
  function UrlObject() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$href = _ref.href,
        href = _ref$href === void 0 ? '' : _ref$href,
        _ref$website = _ref.website,
        website = _ref$website === void 0 ? '' : _ref$website,
        _ref$protocol = _ref.protocol,
        protocol = _ref$protocol === void 0 ? '' : _ref$protocol,
        _ref$domain = _ref.domain,
        domain = _ref$domain === void 0 ? '' : _ref$domain,
        _ref$accessPath = _ref.accessPath,
        accessPath = _ref$accessPath === void 0 ? '' : _ref$accessPath,
        _ref$params = _ref.params,
        params = _ref$params === void 0 ? {} : _ref$params,
        _ref$url = _ref.url,
        url = _ref$url === void 0 ? '' : _ref$url,
        _ref$port = _ref.port,
        port = _ref$port === void 0 ? 0 : _ref$port;

    classCallCheck(this, UrlObject);

    /**
     * @type {String} 不包含网站域名的链接
     */
    this.href = href;
    /**
     * @type {String} URL 站点
     */

    this.website = website;
    /**
     * @type {String} 协议
     */

    this.protocol = protocol;
    /**
     * @type {String} 域名
     */

    this.domain = domain;
    /**
     * @type {String} 绝对路径,不包含参数
     */

    this.accessPath = accessPath;
    /**
     * @type {Object} 参数列表,
     */

    this.params = params;
    /**
     * @type {String} 原 url 链接
     */

    this.url = url;
    /**
     * @type {Number} 端口号
     */

    this.port = port;
  };
  /**
   * 协议与默认端口映射表
   */


  var protocol2Port = {
    http: 80,
    https: 443,
    ssh: 22,
    ftp: 21
    /**
     * 解析 url 字符串
     * @param {String} url url 字符串，不能为空
     * @returns {UrlObject} url 对象
     */

  };
  function parseUrl(url) {
    if (!url) {
      throw new Error('url 不能为空');
    }

    var regexp = new RegExp('^((\\w+)://([\\w\\.]*)(:(\\d+))?)(.*)');
    var temps = regexp.exec(url);
    var res = new UrlObject({
      url: url,
      website: temps[1],
      protocol: temps[2],
      domain: temps[3],
      // @ts-ignore
      port: temps[5],
      href: temps[6]
    });
    var temp = url.substr(res.website.length);
    var markIndex = temp.indexOf('?');

    if (markIndex === -1) {
      res.accessPath = temp;
      return res;
    }

    res.accessPath = temp.substr(0, markIndex);

    if (res.accessPath.endsWith('/')) {
      res.accessPath = res.accessPath.substring(0, res.accessPath.length - 1);
    }

    res.port = res.port || protocol2Port[res.protocol] || ''; // 解析参数列表

    res.params = temp.substr(markIndex + 1).split('&').map(function (str) {
      return str.split('=');
    }).filter(function (arr) {
      return arr[0] !== '';
    }).reduce(function (params, arr) {
      var k = decodeURIComponent(arr[0]);
      var v = decodeURIComponent(arr.length === 1 ? '' : arr[1]); // 如果已经存在了就认为是数组参数

      var vs = params[k];

      if (vs !== undefined) {
        if (!Array.isArray(vs)) {
          params[k] = [vs];
        }

        params[k].push(v);
      } else {
        params[k] = v;
      }

      return params;
    }, {});
    return res;
  }

  /**
   * 读取本地浏览器选择的文件
   * @param {File} file 选择的文件
   * @param {Object} option 可选项参数
   * @param { readLocal.DataURL | readLocal.Text | readLocal.BinaryString | readLocal.ArrayBuffer } [option.type=readLocal.DataURL] 读取的类型，默认按照二进制 url 读取
   * @param {String} [option.encoding='UTF-8'] 读取的编码格式，默认为 UTF-8
   * @returns {Promise} 返回了读取到的内容（异步）
   */
  function readLocal(file) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? readLocal.DataURL : _ref$type,
        _ref$encoding = _ref.encoding,
        encoding = _ref$encoding === void 0 ? 'UTF-8' : _ref$encoding;

    return new Promise(function (resolve, reject) {
      if (!file) {
        reject(new Error('file not exists'));
      }

      var fr = new FileReader();

      fr.onload = function (event) {
        // @ts-ignore
        resolve(event.target.result);
      };

      fr.onerror = function (error) {
        reject(error);
      };

      fr[type](file, encoding);
    });
  }
  readLocal.DataURL = 'readAsDataURL';
  readLocal.Text = 'readAsText';
  readLocal.BinaryString = 'readAsBinaryString';
  readLocal.ArrayBuffer = 'readAsArrayBuffer';

  /**
   * 为 js 中的 Date 对象原型添加 format 格式化方法
   * @param {Date} date 要进行格式化的日期
   * @param {String} fmt 日期的格式
   * @returns {String} 格式化得到的结果
   */
  function dateFormat(date, fmt) {
    var o = {
      'y+': date.getFullYear(),
      'M+': date.getMonth() + 1,
      // 月份
      'd+': date.getDate(),
      // 日
      'h+': date.getHours(),
      // 小时
      'm+': date.getMinutes(),
      // 分
      's+': date.getSeconds(),
      // 秒
      'q+': Math.floor((date.getMonth() + 3) / 3),
      // 季度
      'S+': date.getMilliseconds() // 毫秒

    };

    for (var k in o) {
      if (!new RegExp('(' + k + ')').test(fmt)) {
        continue;
      }

      if (k === 'y+') {
        fmt = fmt.replace(RegExp.$1, ('' + o[k]).substr(4 - RegExp.$1.length));
      } else if (k === 'S+') {
        var lens = RegExp.$1.length;
        lens = lens === 1 ? 3 : lens;
        fmt = fmt.replace(RegExp.$1, ('00' + o[k]).substr(('' + o[k]).length - 1, lens));
      } else {
        fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length));
      }
    }

    return fmt;
  }

  /**
   * 默认的日期格式
   * 不加 Z 为本地日期时间
   */

  var deteFormatter = 'yyyy-MM-ddThh:mm:ss.SSS';
  /**
   * 编码函数
   * @param {String} k 参数的名字
   * @param {String} v 参数的值
   */

  var encode = function encode(k, v) {
    return encodeURIComponent(k) + '=' + encodeURIComponent(v);
  };
  /**
   * 拼接参数字符串
   * @param {Object} params 参数对象
   * @returns {String} 拼接后的字符串
   */


  function spliceParams() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!(params instanceof Object)) {
      throw new Error("The parameter type must be Object: ".concat(params));
    }

    return Array.from(Object.entries(params)).reduce(function (res, _ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      if (v === undefined || v === null) {
        return res;
      } else if (v instanceof Date) {
        res += encode(k, dateFormat(v, deteFormatter));
      } else if (v instanceof Array) {
        res += v.map(function (item) {
          return encode(k, item instanceof Date ? dateFormat(item, deteFormatter) : item);
        }).join('&');
      } else {
        res += encode(k, v);
      }

      return res += '&';
    }, '');
  }

  /**
   * 为 fetch 请求添加超时选项
   * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果
   * @param {Promise} fetchPromise fetch 请求的 Promise
   * @param {Number} timeout 超时时间
   * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果
   */
  function fetchTimeout(fetchPromise, timeout) {
    var abortFn = null; // 这是一个可以被 reject 的 Promise

    var abortPromise = new Promise(function (resolve, reject) {
      abortFn = function abortFn() {
        reject(new Error('abort promise'));
      };
    }); // 有一个 Promise 完成就立刻结束

    var abortablePromise = Promise.race([fetchPromise, abortPromise]);
    setTimeout(function () {
      abortFn();
    }, timeout);
    return abortablePromise;
  }

  /**
   * 将字符串转为字符流
   *
   * @param {String} str 字符串
   * @returns {ArrayBuffer} 字符流对象
   */
  function strToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length);
    var view = new Uint8Array(buf);

    for (var i = 0; i !== str.length; ++i) {
      view[i] = str.charCodeAt(i) & 0xff;
    }

    return buf;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  /**
   * 等待指定的时间/等待指定表达式成立
   * 如果未指定等待条件则立刻执行
   * @param {Number|Function} [param] 等待时间/等待条件
   * @returns {Promise} Promise 对象
   */
  var wait = function wait(param) {
    return new Promise(function (resolve) {
      if (typeof param === 'number') {
        setTimeout(resolve, param);
      } else if (typeof param === 'function') {
        var timer = setInterval(function () {
          if (param()) {
            clearInterval(timer);
            resolve();
          }
        }, 100);
      } else {
        resolve();
      }
    });
  };

  /**
   * 限制并发请求数量的 fetch 封装
   * @class FetchLimiting
   * @example
   * const fetchLimiting = new FetchLimiting()
   * fetchLimiting._fetch('/')
   *   .then(res => res.json())
   *   .then(json => console.log(json))
   */

  var FetchLimiting =
  /*#__PURE__*/
  function () {
    /**
     * 构造函数
     * @param {Object} [option] 可选配置项
     * @param {Number} [option.timeout=10000] 超时毫秒数
     * @param {Number} [option.limit=10] 最大并发数限制
     */
    function FetchLimiting(_ref) {
      var _ref$timeout = _ref.timeout,
          timeout = _ref$timeout === void 0 ? 10000 : _ref$timeout,
          _ref$limit = _ref.limit,
          limit = _ref$limit === void 0 ? 10 : _ref$limit;

      classCallCheck(this, FetchLimiting);

      /**
       * @field timeout 超时毫秒数
       */
      this.timeout = timeout;
      /**
       * @field limit 最大并发数限制
       */

      this.limit = limit;
      /**
       * @field execCount 当前正在执行异步的数量
       */

      this.execCount = 0;
      /**
       * @field waitArr 等待的队列
       * @type {Array.<IArguments>}
       */

      this.waitArr = [];
    }
    /**
     * 执行一个请求
     * 如果到达最大并发限制时就进行等待
     * @param {RequestInfo} url 请求 url 信息
     * @param {RequestInit} [init=undefined] 请求的其他可选项，默认为 undefined
     * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果
     */


    createClass(FetchLimiting, [{
      key: "fetch",
      value: function (_fetch) {
        function fetch(_x, _x2) {
          return _fetch.apply(this, arguments);
        }

        fetch.toString = function () {
          return _fetch.toString();
        };

        return fetch;
      }(
      /*#__PURE__*/
      function () {
        var _ref2 = asyncToGenerator(
        /*#__PURE__*/
        regenerator.mark(function _callee2(url, init) {
          var _this = this;

          var _innerFetch,
              _args2 = arguments;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _innerFetch =
                  /*#__PURE__*/
                  function () {
                    var _ref3 = asyncToGenerator(
                    /*#__PURE__*/
                    regenerator.mark(function _callee() {
                      var args;
                      return regenerator.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _this.execCount++;
                              args = _this.waitArr.shift();
                              _context.prev = 2;
                              _context.next = 5;
                              return fetchTimeout(fetch.apply(void 0, toConsumableArray(args)), _this.timeout);

                            case 5:
                              return _context.abrupt("return", _context.sent);

                            case 6:
                              _context.prev = 6;
                              _this.execCount--;
                              return _context.finish(6);

                            case 9:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, null, [[2,, 6, 9]]);
                    }));

                    return function _innerFetch() {
                      return _ref3.apply(this, arguments);
                    };
                  }();

                  this.waitArr.push(_args2);
                  _context2.next = 4;
                  return wait(function () {
                    return _this.execCount < _this.limit;
                  });

                case 4:
                  return _context2.abrupt("return", _innerFetch());

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        return function (_x3, _x4) {
          return _ref2.apply(this, arguments);
        };
      }())
    }]);

    return FetchLimiting;
  }();

  /**
   * 将一个 Iterator 迭代器转换为一个 Array
   * 目前 {@override Array.from} 已取代改函数
   * @param {Iterator.<Object>} iterator Iterator 迭代器
   * @return {Array.<Object>} Iterator 中每一项元素转换而得到的 Array
   */
  function asIterator(iterator) {
    var arr = [];

    while (true) {
      var next = iterator.next();

      if (next.done) {
        break;
      }

      arr.push(next.value);
    }

    return arr;
  }

  /**
   * 将数组异步压平一层
   * @param {Array.<Object>} arr 数组
   * @param {Function} fn 映射函数，将一个元素映射为一个数组
   * @returns {Promise.<Array.<Object>>} 压平一层的数组
   */
  function asyncFlatMap(_x, _x2) {
    return _asyncFlatMap.apply(this, arguments);
  }

  function _asyncFlatMap() {
    _asyncFlatMap = asyncToGenerator(
    /*#__PURE__*/
    regenerator.mark(function _callee(arr, fn) {
      var res, i;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              res = [];
              _context.t0 = regenerator.keys(arr);

            case 2:
              if ((_context.t1 = _context.t0()).done) {
                _context.next = 11;
                break;
              }

              i = _context.t1.value;
              _context.t2 = res;
              _context.next = 7;
              return fn(arr[i]);

            case 7:
              _context.t3 = _context.sent;
              res = _context.t2.concat.call(_context.t2, _context.t3);
              _context.next = 2;
              break;

            case 11:
              return _context.abrupt("return", res);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _asyncFlatMap.apply(this, arguments);
  }

  /**
   * 自行实现 flatMap，将数组压平一层
   * @param {Array.<Object>} arr 数组
   // @ts-ignore
   * @param {function(item:Object):Array.<Object>} fn 映射方法，将一个元素映射为一个数组
   * @returns {Array.<Object>} 压平一层的数组
   */
  function flatMap(arr, fn) {
    // @ts-ignore
    return arr.reduce(function (res, item) {
      return res.concat(fn(item));
    }, []);
  }

  /**
   * js 数组按照某个条件进行分组
   *
   * @param {Array<Object>} arr 要进行分组的数组
   * @param {Function} fn 元素分组的方法
   * @returns {Map<Object,Object>} 对象 -> 数组映射对象
   */
  function groupBy(arr, fn) {
    // 将元素按照分组条件进行分组得到一个 条件 -> 数组 的对象
    return arr.reduce(function (res, item) {
      var name = fn(item); // 如果已经有这个键了就直接追加, 否则先将之赋值为 [] 再追加元素

      if (!res.has(name)) {
        res.set(name, []);
      }

      res.get(name).push(item);
      return res;
    }, new Map());
  }

  /**
   * 创建一个等差数列数组
   * @param {Number} start 开始（包含）
   * @param {Number} end 结束（不包含）
   * @param {Number} [sep] 步长，默认为 1
   * @returns {Array.<Number>} 等差数列数组
   */
  function range(start, end) {
    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var arr = [];

    for (var i = start; i < end; i += sep) {
      arr.push(i);
    }

    return arr;
  }

  /**
   * 将数组转化为一个 Object 对象
   * @deprecated 已废弃，请使用更好的 @override arrayToMap 替代
   * @param {Array.<Object>} arr 需要进行转换的数组
   * @param {Function} kFn 生成对象属性名的函数
   * @param {Function} [vFn] 生成对象属性值的函数，默认为数组中的迭代元素
   * @returns {Object} 转化得到的对象
   */
  function toObject(arr, kFn) {
    var vFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (item) {
      return item;
    };
    return arr.reduce(function (res, item) {
      if (!res.hasOwnProperty(kFn(item))) {
        res[kFn(item)] = vFn(item);
      }

      return res;
    }, {});
  }

  /**
   * js 的数组去重方法
   * @param {Array.<Object>} arr 要进行去重的数组
   * @param {Function} [fn=item => JSON.stringify(item)] 唯一标识元素的方法，默认使用 {@link JSON.stringify()}
   * @returns {Array.<Object>} 进行去重操作之后得到的新的数组 (原数组并未改变)
   */
  function uniqueBy(arr) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (item) {
      return JSON.stringify(item);
    };
    var obj = {};
    return arr.filter(function (item) {
      return obj.hasOwnProperty(fn(item)) ? false : obj[fn(item)] = true;
    });
  }

  /**
   * 将数组映射为 Map
   * @param {Array.<Object>} array 数组
   * @param {function} kFn 产生 Map 元素唯一标识的函数
   * @param {Function} [vFn] 产生 Map 值的函数，默认为返回数组的元素
   * @returns {Map.<Object,Object>} 映射产生的 map 集合
   */
  function arrayToMap(array, kFn) {
    var vFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (v) {
      return v;
    };
    return array.reduce(function (res, item) {
      res.set(kFn(item), vFn(item));
      return res;
    }, new Map());
  }

  /**
   * 填充字符串到指定长度
   * @param {String} item 填充的字符串
   * @param {Number} len 填充的长度
   * @returns {String} 填充完成的字符串
   */
  function fill(item, len) {
    if (len <= 0) {
      return '';
    }

    return item + fill(item, len - 1);
  }

  /**
   * 日期格式化类
   * @class DateFormat
   */

  var DateFormat =
  /**
   * 构造函数
   * @param {String} name 日期格式的名称
   * @param {String} format 日期的格式值
   * @param {String} value 格式化得到的值
   * @param {Number} index 需要替换位置的索引
   */
  function DateFormat(name, format, value, index) {
    classCallCheck(this, DateFormat);

    /**
     * @field 日期格式的名称
     */
    this.name = name;
    /**
     * @field 日期的格式值
     */

    this.format = format;
    /**
     * @field 格式化得到的值
     */

    this.value = value;
    /**
     * @field 需要替换位置的索引
     */

    this.index = index;
  };
  /**
   * 日期时间的正则表达式
   */


  var dateFormats = {
    year: 'y{4}|y{2}',
    month: 'M{1,2}',
    day: 'd{1,2}',
    hour: 'h{1,2}',
    minute: 'm{1,2}',
    second: 's{1,2}',
    milliSecond: 'S{1,3}'
    /**
     * 解析字符串为 Date 对象
     * @param {String} dateStr 日期字符串
     * @param {String} fmt 日期字符串的格式，目前仅支持使用 y(年),M(月),d(日),h(时),m(分),s(秒),S(毫秒)
     * @returns {Date} 解析得到的 Date 对象
     */

  };
  function dateParse(dateStr, fmt) {
    var now = new Date(); // 如果没有格式化某项的话则设置为默认时间

    var defaultDateValues = {
      year: now.getFullYear().toString(),
      month: '01',
      day: '01',
      hour: '00',
      minute: '00',
      second: '00',
      milliSecond: '000' // 保存对传入的日期字符串进行格式化的全部信息数组列表

    };
    var dateUnits = [];

    for (var fmtName in dateFormats) {
      var regExp = new RegExp(dateFormats[fmtName]);

      if (regExp.test(fmt)) {
        var matchStr = regExp.exec(fmt)[0];
        var regexStr = fill('`', matchStr.length);
        var index = fmt.indexOf(matchStr);
        fmt = fmt.replace(matchStr, regexStr);
        dateUnits.push(new DateFormat(fmtName, fill('\\d', matchStr.length), null, index));
      } else {
        dateUnits.push(new DateFormat(fmtName, null, defaultDateValues[fmtName], -1));
      }
    } // 进行验证是否真的是符合传入格式的字符串


    fmt = fmt.replace(new RegExp('`', 'g'), '\\d');

    if (!new RegExp("^".concat(fmt, "$")).test(dateStr)) {
      return null;
    } // 进行一次排序, 依次对字符串进行截取


    dateUnits // 过滤掉没有得到格式化的对象
    .filter(function (_ref) {
      var format = _ref.format;
      return format;
    }) // 按照字符串中日期片段的索引进行排序
    .sort(function (a, b) {
      return a.index - b.index;
    }) // 获取到匹配的日期片段的值
    .map(function (format) {
      var matchDateUnit = new RegExp(format.format).exec(dateStr);

      if (matchDateUnit !== null && matchDateUnit.length > 0) {
        dateStr = dateStr.replace(matchDateUnit[0], '');
        format.value = matchDateUnit[0];
      }

      return format;
    }) // 覆写到 dateStr 上面
    .forEach(function (_ref2, i) {
      var format = _ref2.format;
      var matchDateUnit = new RegExp(format).exec(dateStr);

      if (matchDateUnit !== null && matchDateUnit.length > 0) {
        dateStr = dateStr.replace(matchDateUnit[0], '');
        dateUnits[i].value = matchDateUnit[0];
      }
    }); // 将截取完成的信息封装成对象并格式化标准的日期字符串

    var map = arrayToMap(dateUnits, function (item) {
      return item.name;
    }, function (item) {
      return item.value;
    });

    if (map.get('year').length === 2) {
      map.set('year', defaultDateValues.year.substr(0, 2).concat(map.get('year')));
    } // 注意：此处使用的是本地时间而非 UTC 时间


    var date = "".concat(map.get('year'), "-").concat(map.get('month'), "-").concat(map.get('day'), "T").concat(map.get('hour'), ":").concat(map.get('minute'), ":").concat(map.get('second'), ".").concat(map.get('milliSecond'));
    return new Date(date);
  }

  /**
   * 解析字符串为 Date 对象
   * @deprecated 已弃用，请使用可读性更好的 {@link dateParse} 代替
   * @param {String} dateStr 日期字符串
   * @param {String} fmt 日期字符串的格式
   * 目前仅支持使用 y(年),M(月),d(日),h(时),m(分),s(秒),S(毫秒)
   * @returns {Date} 解析得到的 Date 对象
   */

  function strToDate(dateStr, fmt) {
    return dateParse(dateStr, fmt);
  }

  /**
   * 复制一段文本内容
   * @param {String} text 要进行复制的文本
   * @returns {Boolean} 是否复制成功
   */
  function copyText(text) {
    var input = document.createElement('input');
    document.body.appendChild(input);
    input.setAttribute('value', text);
    input.select();
    var res = document.execCommand('copy');
    document.body.removeChild(input);
    return res;
  }

  /**
   * 根据 html 字符串创建 Element 元素
   * @param {String} str html 字符串
   * @returns {Element} 创建的 Element 元素
   */
  function createElByString(str) {
    var root = document.createElement('div');
    root.innerHTML = str;
    return root.querySelector('*');
  }

  /**
   * 获取输入框中光标所在位置
   * @param  {HTMLFormElement} el 需要获取的输入框元素
   * @returns {Number} 光标所在位置的下标
   */
  function getCusorPostion(el) {
    return el.selectionStart;
  }

  /**
   * 设置输入框中选中的文本/光标所在位置
   * @param {HTMLFormElement} el 需要设置的输入框元素
   * @param {Number} start 光标所在位置的下标
   * @param {Number} [end=start] 结束位置，默认为输入框结束
   */
  function setCusorPostion(el, start) {
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : start;
    el.focus();
    el.setSelectionRange(start, end);
  }

  /**
   * 在指定位置后插入文本
   * @param {HTMLFormElement} el 需要设置的输入框元素
   * @param {String} text 要插入的值
   * @param {Number} [start] 开始位置，默认为当前光标处
   */

  function insertText(el, text) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getCusorPostion(el);
    var value = el.value;
    el.value = value.substr(0, start) + text + value.substr(start);
    setCusorPostion(el, start + text.length);
  }

  /**
   * 字符串安全的转换为小写
   * @param {String} str 字符串
   * @returns {String} 转换后得到的全小写字符串
   */
  function toLowerCase(str) {
    if (!str || typeof str !== 'string') {
      return str;
    }

    return str.toLowerCase();
  }

  /**
   * 判断指定元素是否是可编辑元素
   * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素
   * @param {Element} el 需要进行判断的元素
   * @returns {Boolean} 是否为可编辑元素
   */

  function isEditable(el) {
    var inputEls = ['input', 'date', 'datetime', 'select', 'textarea'];
    return (// 此处需要判断是否存在属性 isContentEditable
      // @ts-ignore
      el && (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))
    );
  }

  var lastFocusEl;
  document.addEventListener('focus', function (event) {
    lastFocusEl = event.target;
  }, true);
  document.addEventListener('blur', function () {
    lastFocusEl = null;
  }, true);
  /**
   * 获取到最后一个获得焦点的元素
   * @returns {Element} 最后一个获取到焦点的元素
   */

  function lastFocus() {
    return lastFocusEl;
  }

  /**
   * 直接删除指定元素
   * @param {Element} el 需要删除的元素
   * @returns {Element} 返回被删除的元素
   */
  function removeEl(el) {
    var parent = el.parentElement;
    return parent.removeChild(el);
  }

  /**
   * 在指定范围内删除文本
   * @param {HTMLFormElement} el 需要设置的输入框元素
   * @param {Number} [start] 开始位置，默认为当前选中开始位置
   * @param {Number} [end] 结束位置，默认为当前选中结束位置
   */

  function removeText(el) {
    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : el.selectionStart;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : el.selectionEnd;
    // 删除之前必须要 [记住] 当前光标的位置
    var index = getCusorPostion(el);
    var value = el.value;
    el.value = value.substr(0, start) + value.substr(end, value.length);
    setCusorPostion(el, index);
  }

  /**
   * 监听 event 的添加
   * 注：必须及早添加
   */
  function watchEventListener() {
    /**
     * 监听所有的 addEventListener, removeEventListener 事件
     */
    var documentAddEventListener = document.addEventListener;
    var eventTargetAddEventListener = EventTarget.prototype.addEventListener;
    var documentRemoveEventListener = document.removeEventListener;
    var eventTargetRemoveEventListener = EventTarget.prototype.removeEventListener;
    var events = [];
    /**
     * 用来保存监听到的事件信息
     */

    var Event = function Event(el, type, listener, useCapture) {
      classCallCheck(this, Event);

      this.el = el;
      this.type = type;
      this.listener = listener;
      this.useCapture = useCapture;
    };
    /**
     * 自定义的添加事件监听函数
     * @param {String} type 事件类型
     * @param {EventListener} listener 事件监听函数
     * @param {Boolean} [useCapture=true] 是否需要捕获事件冒泡，默认为 false
     */


    function addEventListener(type, listener) {
      var useCapture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var _this = this;

      var $addEventListener = _this === document ? documentAddEventListener : eventTargetAddEventListener;
      events.push(new Event(_this, type, listener, useCapture));
      $addEventListener.apply(this, arguments);
    }
    /**
     * 自定义的根据类型删除事件函数
     * 该方法会删除这个类型下面全部的监听函数，不管数量
     * @param {String} type 事件类型
     */
    // @ts-ignore


    function removeEventListenerByType(type) {
      var _arguments = arguments;

      var _this = this;

      var $removeEventListener = _this === document ? documentRemoveEventListener : eventTargetRemoveEventListener;
      var removeIndexArr = events.map(function (e, i) {
        return e.el === _this || e.type === _arguments[0] ? i : -1;
      }).filter(function (i) {
        return i !== -1;
      });
      removeIndexArr.forEach(function (i) {
        var e = events[i];
        $removeEventListener.apply(e.el, [e.type, e.listener, e.useCapture]);
      });
      removeIndexArr.sort(function (a, b) {
        return b - a;
      }).forEach(function (i) {
        return events.splice(i, 1);
      });
    }

    (function initWatchDOM() {
      document.addEventListener = EventTarget.prototype.addEventListener = addEventListener; // 此处是为了新增函数 removeEventListenerByType
      // @ts-ignore

      document.removeEventListenerByType = EventTarget.prototype.removeEventListenerByType = removeEventListenerByType;
    })();
  }

  /**
   * FormData 批量添加方法
   * 注：该方法不会覆盖掉原本的属性
   * @param {FormData} fd FormData 对象
   * @param {Object} obj 键值对对象
   * @returns {FormData} 添加完成后的 FormData 对象
   */
  function appends(fd, obj) {
    for (var key in obj) {
      fd.append(key, obj[key]);
    }

    return fd;
  }

  /**
   * FormData 批量删除方法
   * @param {FormData} fd FormData 对象
   * @param {Array} keys  删除的 key 列表
   * @returns {FormData} 返回删除后的 FormData 对象
   */
  function deletes(fd, keys) {
    keys.forEach(function (key) {
      return fd.delete(key);
    });
    return fd;
  }

  /**
   * FormData 批量设置方法
   * 注：该方法会覆盖掉原本的属性
   * @param {FormData} fd 表单对象
   * @param {Object} obj 键值对对象
   * @returns {FormData} 设置完成后的 FormData 对象
   */
  function sets(fd, obj) {
    for (var k in obj) {
      fd.set(k, obj[k]);
    }

    return fd;
  }

  /**
   * FormData 转换为包含所有键值数组的二维数组函数
   *
   * @param {FormData} fd 需要转换的 FormData 对象
   * @returns {Array} 转换后的数组
   * @deprecated 已被原生函数 Array.from 取代
   */

  function formDataToArray(fd) {
    // @ts-ignore
    return asIterator(fd.entries());
  }

  /**
   * 将参数对象转换为 FormData，只转换一层
   * @param data 参数对象
   * @return {FormData} 转换后的表单对象
   */
  function objToFormData(data) {
    var fd = new FormData();

    if (data) {
      for (var k in data) {
        if (data.hasOwnProperty(k)) {
          var v = data[k];
          fd.append(k, v);
        }
      }
    }

    return fd;
  }

  /**
   * 函数去抖
   * 去抖 (debounce) 去抖就是对于一定时间段的连续的函数调用，只让其执行一次
   * 注: 包装后的函数如果两次操作间隔小于 delay 则不会被执行, 如果一直在操作就会一直不执行, 直到操作停止的时间大于 delay 最小间隔时间才会执行一次, 不管任何时间调用都需要停止操作等待最小延迟时间
   * 应用场景主要在那些连续的操作, 例如页面滚动监听, 包装后的函数只会执行最后一次
   * 注: 该函数第一次调用一定不会执行，第一次一定拿不到缓存值，后面的连续调用都会拿到上一次的缓存值。如果需要在第一次调用获取到的缓存值，则需要传入第三个参数 {@link init}，默认为 {@link undefined} 的可选参数
   * @param {Number} delay 最小延迟时间，单位为 ms
   * @param {Function} action 真正需要执行的操作
   * @param {Object} [init=undefined] 初始的缓存值，不填默认为 {@link undefined}
   * @return {Function} 包装后有去抖功能的函数。该函数是异步的，与需要包装的函数 {@link action} 是否异步没有太大关联
   */
  var debounce = function debounce(delay, action) {
    var init = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    var flag;
    var result = init;
    return function () {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve) {
        if (flag) clearTimeout(flag);
        flag = setTimeout(function () {
          result = action.call.apply(action, [_this].concat(args));
          resolve(result);
        }, delay);
        setTimeout(function () {
          resolve(result);
        }, delay);
      });
    };
  };

  /**
   * 返回参数本身的函数
   * @param {Object} obj 任何对象
   * @returns {Object} 传入的参数
   */
  function returnItself(obj) {
    return obj;
  }

  /**
   * 安全执行某个函数
   * @param {Function} fn 需要执行的函数
   * @param {Object} [defaultVal=undefined] 发生异常后的默认返回值，默认为 undefined
   * @param {...Object} [args] 可选的函数参数
   * @returns {Object|undefined} 函数执行的结果，或者其默认值
   */
  var safeExec = function safeExec(fn) {
    var defaultVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    try {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      return fn.apply(void 0, args);
    } catch (err) {
      return defaultVal;
    }
  };

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  var possibleConstructorReturn = _possibleConstructorReturn;

  var getPrototypeOf = createCommonjsModule(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
  });

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
  });

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  var inherits = _inherits;

  /**
   * 通用的单例模式
   * @param {Object} clazz 需要包装为单例的类型
   * @returns {Object} 包装后的单例模式类，使用 {@code new} 创建将只在第一次有效
   */
  function singleModel(clazz) {
    var instance;
    return (
      /*#__PURE__*/
      function (_clazz) {
        inherits(SingleClass, _clazz);

        /**
         * @param {...Object} args
         */
        function SingleClass() {
          var _getPrototypeOf2;

          var _this;

          classCallCheck(this, SingleClass);

          if (instance) {
            return possibleConstructorReturn(_this, instance);
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = possibleConstructorReturn(this, (_getPrototypeOf2 = getPrototypeOf(SingleClass)).call.apply(_getPrototypeOf2, [this].concat(args)));
          instance = assertThisInitialized(_this);
          return _this;
        }

        return SingleClass;
      }(clazz)
    );
  }

  var construct = createCommonjsModule(function (module) {
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      module.exports = _construct = Reflect.construct;
    } else {
      module.exports = _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  module.exports = _construct;
  });

  /**
   * 状态机
   * 用于避免使用 if-else 的一种方式
   */

  var StateMachine =
  /*#__PURE__*/
  function () {
    function StateMachine() {
      classCallCheck(this, StateMachine);
    }

    createClass(StateMachine, null, [{
      key: "getFactory",

      /**
       * 获取到一个状态工厂
       */
      value: function getFactory() {
        var classMap = new Map();
        /**
         * 状态注册器
         * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类
         */

        return new (
        /*#__PURE__*/
        function () {
          function Builder() {
            classCallCheck(this, Builder);
          }

          createClass(Builder, [{
            key: "register",

            /**
             * 注册一个 class，创建子类时调用，用于记录每一个 [状态 => 子类] 对应
             * @param {Number|String} state 作为键的状态
             * @param {Object} clazz 对应的子类型
             * @returns {Object} 返回 clazz 本身
             */
            value: function register(state, clazz) {
              classMap.set(state, singleModel(clazz));
              return clazz;
            } // noinspection JSMethodCanBeStatic

            /**
             * 获取一个标签子类对象
             * @param {Number|String} state 状态索引
             * @returns {Object} 子类对象
             */

          }, {
            key: "getInstance",
            value: function getInstance(state) {
              var Class = classMap.get(state);

              if (!Class) {
                return null;
              } // 构造函数的参数


              return construct(Class, toConsumableArray(Array.from(arguments).slice(1)));
            }
          }]);

          return Builder;
        }())();
      }
    }]);

    return StateMachine;
  }();

  /**
   * 函数节流
   * 节流 (throttle) 让一个函数不要执行的太频繁，减少执行过快的调用，叫节流
   * 类似于上面而又不同于上面的函数去抖, 包装后函数在上一次操作执行过去了最小间隔时间后会直接执行, 否则会忽略该次操作
   * 与上面函数去抖的明显区别在连续操作时会按照最小间隔时间循环执行操作, 而非仅执行最后一次操作
   * 注: 该函数第一次调用一定会执行，不需要担心第一次拿不到缓存值，后面的连续调用都会拿到上一次的缓存值
   *
   * @param {Number} delay 最小间隔时间，单位为 ms
   * @param {Function} action 真正需要执行的操作
   * @return {Function} 包装后有节流功能的函数。该函数是异步的，与需要包装的函数 {@link action} 是否异步没有太大关联
   */
  var throttle = function throttle(delay, action) {
    var last = 0;
    var result;
    return function () {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve) {
        var curr = Date.now();

        if (curr - last > delay) {
          result = action.call.apply(action, [_this].concat(args));
          last = curr;
          resolve(result);
          return;
        }

        resolve(result);
      });
    };
  };

  /**
   * 测试函数的执行时间
   * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间
   * @param {Function} fn 需要测试的函数
   * @returns {Number|Promise} 执行的毫秒数
   */
  var timing = function timing(fn) {
    // 使用 Proxy 实现了一下，但感觉实际上与原来的差不多（或许是吾辈的使用场景不太对？）
    var proxyFn = new Proxy(fn, {
      apply: function apply(target, thisArg, args) {
        var begin = performance.now();
        var result = Reflect.apply(target, thisArg, args);

        if (!(result instanceof Promise)) {
          return performance.now() - begin;
        }

        return result.then(function () {
          return performance.now() - begin;
        });
      }
    });
    return proxyFn(); // const begin = performance.now()
    // const result = fn()
    // if (!(result instanceof Promise)) {
    //   return performance.now() - begin
    // }
    // return result.then(() => performance.now() - begin)
  };

  /**
   * 轮询等待指定资源加载完毕再执行操作
   * 使用 Promises 实现，可以使用 ES7 的 {@async}/{@await} 调用
   * @param {Function} fn 判断必须的资源是否存在的方法
   * @param {Object} option 可配置项
   * @param {Number} [option.interval=100] 轮询间隔
   * @param {Number} [option.max=10] 最大轮询次数
   * @returns Promise 对象
   */
  var waitResource = function waitResource(fn) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$interval = _ref.interval,
        interval = _ref$interval === void 0 ? 100 : _ref$interval,
        _ref$max = _ref.max,
        max = _ref$max === void 0 ? 10 : _ref$max;

    var current = 0;
    return new Promise(function (resolve, reject) {
      var timer = setInterval(function () {
        if (fn()) {
          clearInterval(timer);
          resolve();
        }

        current++;

        if (current >= max) {
          clearInterval(timer);
          reject(new Error('等待超时'));
        }
      }, interval);
    });
  };

  /**
   * 监视指定函数返回值的变化
   * @param {Function} fn 需要监视的函数
   * @param {Function} callback 回调函数
   * @param {Number} [interval=100] 每次检查的间隔时间，默认为 100ms
   * @returns {Function} 关闭这个监视函数
   */

  var watch = function watch(fn, callback) {
    var interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
    var oldVal = safeExec(fn);
    var timer = setInterval(function () {
      var newVal = safeExec(fn);

      if (oldVal !== newVal) {
        callback(newVal, oldVal);
        oldVal = newVal;
      }
    }, interval);
    return function () {
      return clearInterval(timer);
    };
  };

  /**
   * 定义监听对象时的回调函数 doc
   * @callback WatchObjectCallback
   * @param {Object} target 代理的对象变化后的值
   * @param {String} k 变化的属性名
   * @param {Object} v 变化的属性值
   */

  /**
   * 深度监听指定对象属性的变化
   * 注：指定对象不能是原始类型，即不可变类型，而且对象本身的引用不能改变，最好使用 const 进行声明
   * @param {Object} object 需要监视的对象
   * @param {WatchObjectCallback} callback 当代理对象发生改变时的回调函数，回调函数有三个参数，分别是
   * @returns {Object} 返回源对象的一个代理
   */
  function watchObject(object, callback) {
    var handler = {
      get: function get(target, property, receiver) {
        try {
          return new Proxy(target[property], handler);
        } catch (err) {
          return Reflect.get(target, property, receiver);
        }
      },
      set: function set(target, key, value, receiver) {
        callback(target, key, value);
        return Reflect.set(target, key, value, receiver);
      }
    };
    return new Proxy(object, handler);
  }

  /**
   * 字符串格式化
   *
   * @param {String} str 要进行格式化的值
   * @param {Object} args 格式化参数值，替换字符串中的 {} 的值
   * @returns {String} 替换完成的字符串
   * @deprecated 已废弃，请使用 ES6 模板字符串 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings
   */
  function format(str, args) {
    if (!args) {
      return str;
    }

    return Object.keys(args).reduce(function (res, k) {
      return res.replace(new RegExp("{".concat(k, "}"), 'g'), args[k]);
    }, str);
  }

  /**
   * 判断是否为小数的正则表达式
   */
  var regexp = new RegExp('^(-?\\d+)(.\\d+)?$');
  /**
   * 判断字符串是否位小数
   * @param {String} str 需要进行判断的字符串
   * @returns {Boolean} 是否为小数
   */

  function isFloat(str) {
    return regexp.test(str);
  }

  /**
   * 判断是否为整数的正则表达式
   */
  var regexp$1 = new RegExp('^-?\\d+$');
  /**
   * 判断字符串是否位整数
   * @param {String} str 需要进行判断的字符串
   * @returns {Boolean} 是否为小数
   */

  function isNumber(str) {
    return regexp$1.test(str);
  }

  /**
   * 字符串安全的转换为大写
   * @param {String} str 字符串
   * @returns {String} 转换后得到的全大写字符串
   */
  function toUpperCase(str) {
    if (!str || typeof str !== 'string') {
      return str;
    }

    return str.toUpperCase();
  }

  /**
   * 将空白字符串转换为 null
   *
   * @param {String} str 将空字符串转换为 {@code null}
   * @returns {String} 可能为 {@code null}
   */
  function blankToNull(str) {
    return !str || str.trim().length === 0 ? null : str;
  }

  /**
   * 置空对象所有空白的属性
   *
   * @param {Object} obj 对象
   * @returns {Object} 将所有的空白属性全部转换为 null 的新对象
   */

  function blankToNullField(obj) {
    var res = {};

    for (var k in obj) {
      var v = obj[k];
      res[k] = typeof v === 'string' ? blankToNull(v) : v;
    }

    return res;
  }

  /**
   * 将对象的所有属性置空
   * @param {Object} obj 需要置空属性的对象
   * @returns {Object} 返回一个新的对象
   */
  function emptyAllField(obj) {
    var res = {};

    for (var k in obj) {
      res[k] = null;
    }

    return res;
  }

  /**
   * 排除对象中的指定字段
   * 注: 此处将获得一个浅拷贝对象
   * @param {Object} object 排除对象
   * @param {...String} fields 要排除的字段
   * @returns {Object} 排除完指定字段得到的新的对象
   */
  function excludeFields(object) {
    for (var _len = arguments.length, fields = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      fields[_key - 1] = arguments[_key];
    }

    var set = new Set(fields);
    return Object.entries(object).reduce(function (res, _ref) {
      var _ref2 = slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      if (!set.has(k)) {
        res[k] = v;
      }

      return res;
    }, {});
  }

  /**
   * 将 map 转换为 Object 对象
   * @param {Map} map map 键值表
   * @returns {Object} 转换得到的 Object 对象
   */
  function mapToObject(map) {
    var res = {}; // @ts-ignore

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = map[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = slicedToArray(_step.value, 2),
            k = _step$value[0],
            v = _step$value[1];

        res[k] = v;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return res;
  }

  /**
   * 生成一个随机的数字
   * 如果没有参数，则会抛出异常
   * @param {Number} args 参数列表，如果只有一个参数，则认为是最大值，最小值为 0。否则认为第一个是最小值，第二个是最大值，忽略剩余的参数
   * @returns {Number} 生成的随机整数
   */
  function randomInt() {
    var min;
    var max;

    if (arguments.length === 0) {
      throw new Error('非法参数，必须指定最大值');
    } else if (arguments.length === 1) {
      min = 0;
      max = arguments.length <= 0 ? undefined : arguments[0];
    } else if (arguments.length > 1) {
      min = arguments.length <= 0 ? undefined : arguments[0];
      max = arguments.length <= 1 ? undefined : arguments[1];
    }

    return min + Math.floor(Math.random() * (max - min));
  }

  /**
   * 获取一年内的第多少星期
   * @deprecated 不推荐使用，请使用 {@link dateEnhance} 代替
   * @returns {Number}
   */
  function getYearWeek(date) {
    /*
      date1是当前日期
      date2是当年第一天
      d是当前日期是今年第多少天
      用d + 当前年的第一天的周差距的和在除以7就是本年第几周
      */
    var nowTime = date.getTime();
    var startTime = new Date(date.getFullYear(), 0, 1).getTime();
    var difTime = nowTime - startTime;
    return Math.floor(difTime / (24 * 3600 * 1000) / 7);
  }

  /**
   * 日期固定时间点
   * @class DateConstants
   */

  var DateConstants =
  /*#__PURE__*/
  function () {
    function DateConstants() {
      classCallCheck(this, DateConstants);
    }

    createClass(DateConstants, [{
      key: "dayStart",

      /**
       * 获取指定日期一天的开始时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 一天的开始时间
       */
      value: function dayStart() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(dateFormat(date, 'yyyy-MM-dd'), "T00:00:00.000"));
      }
      /**
       * 获取指定日期一天的结束时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 一天的结束时间
       */

    }, {
      key: "dayEnd",
      value: function dayEnd() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(dateFormat(date, 'yyyy-MM-dd'), "T23:59:59.999"));
      }
      /**
       * 获取指定日期所在年份的新年开始时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 新年开始时间
       */

    }, {
      key: "yearStart",
      value: function yearStart() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(date.getFullYear(), "-01-01T00:00:00.000"));
      }
      /**
       * 获取指定日期所在年份的旧年结束时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 旧年结束时间
       */

    }, {
      key: "yearEnd",
      value: function yearEnd() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(date.getFullYear(), "-12-31T23:59:59.999"));
      }
    }]);

    return DateConstants;
  }();
  /**
   * 导出一个日期固定时间点的对象
   * @type {DateConstants}
   */

  var dateConstants = new DateConstants();

  /**
   * 判断数字是否在指定区间之中
   * @param {Number} num 指定数字
   * @param {Number} min 最小值
   * @param {Number} max 最大值（不包含）
   */
  function isRange(num, min, max) {
    if (min > max) {
      var _ref = [max, min];
      min = _ref[0];
      max = _ref[1];
    }

    return num >= min && num < max;
  }

  /**
   * 日期固定时间点
   * @class DateConstants
   */

  var DateConstants$1 =
  /*#__PURE__*/
  function () {
    function DateConstants() {
      classCallCheck(this, DateConstants);
    }

    createClass(DateConstants, [{
      key: "dayStart",

      /**
       * 获取指定日期一天的开始时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 一天的开始时间
       */
      value: function dayStart() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(dateFormat(date, 'yyyy-MM-dd'), "T00:00:00.000"));
      }
      /**
       * 获取指定日期一天的结束时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 一天的结束时间
       */

    }, {
      key: "dayEnd",
      value: function dayEnd() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(dateFormat(date, 'yyyy-MM-dd'), "T23:59:59.999"));
      }
      /**
       * 获取指定日期所在年份的新年开始时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 新年开始时间
       */

    }, {
      key: "yearStart",
      value: function yearStart() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(date.getFullYear(), "-01-01T00:00:00.000"));
      }
      /**
       * 获取指定日期所在年份的旧年结束时间
       * @param {Date} [date=new Date()] 指定的时间，默认为当前日期
       * @returns {Date} 旧年结束时间
       */

    }, {
      key: "yearEnd",
      value: function yearEnd() {
        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        return new Date("".concat(date.getFullYear(), "-12-31T23:59:59.999"));
      }
    }]);

    return DateConstants;
  }();
  /**
   * 导出一个日期固定时间点的对象
   * @type {DateConstants}
   */

  var dateConstants$1 = new DateConstants$1();

  /**
   * 一天标准的毫秒数
   */

  var DAY_UNIT_TIME = 1000 * 60 * 60 * 24;
  /**
   * 日期增强
   */

  var DateEnhance =
  /*#__PURE__*/
  function () {
    /**
     * 构造函数
     * @param {Date} date 要增强的日期
     */
    function DateEnhance(date) {
      classCallCheck(this, DateEnhance);

      /**
       * @field 要增强的日期
       */
      this.date = date;
    }
    /**
     * 获取到年份
     * @returns {Number}
     */


    createClass(DateEnhance, [{
      key: "year",
      value: function year() {
        return this.date.getFullYear();
      }
      /**
       * 获取月份
       * @returns {Number}
       * @deprecated 已废弃，请使用 {@link this#monthOfYear} 函数
       */

    }, {
      key: "month",
      value: function month() {
        return this.date.getMonth();
      }
      /**
       * 获取今年的第几个月份
       * 和 {@link this#month} 不同的是不再从 0 计算月份
       */

    }, {
      key: "monthOfYear",
      value: function monthOfYear() {
        return this.date.getMonth() + 1;
      }
      /**
       * 获取一年内的第多少天
       * 注: 这个天数指定的在第几天而非过去了多少天，例如 2018-01-10 的结果会是 10
       * @returns {Number}
       */

    }, {
      key: "dayOfYear",
      value: function dayOfYear() {
        return Math.ceil((this.date.getTime() - dateConstants$1.yearStart(this.date).getTime()) / DAY_UNIT_TIME);
      }
      /**
       * 获取一个月内的第多少天
       * 注: 这个天数指的是在第几天而非过去了多少天，例如 2018-01-10 的结果会是 10
       * @returns {Number}
       */

    }, {
      key: "dayOfMonth",
      value: function dayOfMonth() {
        return this.date.getDate();
      }
      /**
       * 获取一个星期内的第多少天
       * @returns {Number}
       */

    }, {
      key: "dayOfWeek",
      value: function dayOfWeek() {
        return this.date.getDay();
      }
      /**
       * 获取一年内的第多少星期
       * 注: 这个星期指定的在第几天而非过去了多少天，例如 2018-01-10 的结果会是 10
       * @returns {Number}
       */

    }, {
      key: "weekOfYear",
      value: function weekOfYear() {
        return Math.ceil(this.dayOfYear() / 7);
      }
      /**
       * 获取一个月内的第多少星期
       * @returns {Number}
       */

    }, {
      key: "weekOfMonth",
      value: function weekOfMonth() {
        return Math.ceil(this.dayOfMonth() / 7);
      }
      /**
       * 获取季度
       * @returns {Number}
       */

    }, {
      key: "quarter",
      value: function quarter() {
        var month = this.month();

        if (isRange(month, 0, 3)) {
          return 1;
        } else if (isRange(month, 3, 6)) {
          return 2;
        } else if (isRange(month, 6, 9)) {
          return 3;
        } else {
          return 4;
        }
      }
      /**
       * 获取小时
       * @returns {Number}
       */

    }, {
      key: "hour",
      value: function hour() {
        return this.date.getHours();
      }
      /**
       * 获取分钟
       * @returns {Number}
       */

    }, {
      key: "minute",
      value: function minute() {
        return this.date.getMinutes();
      }
      /**
       * 获取秒
       * @returns {Number}
       */

    }, {
      key: "second",
      value: function second() {
        return this.date.getSeconds();
      }
      /**
       * 获取毫秒
       * @returns {Number}
       */

    }, {
      key: "milliSecond",
      value: function milliSecond() {
        return this.date.getMilliseconds();
      }
    }]);

    return DateEnhance;
  }();
  /**
   * 获取一个增强的日期
   * @param {Date} date 要增强的日期
   * @returns {DateEnhance} 增强日期
   */

  function dateEnhance(date) {
    return new DateEnhance(date);
  }

  /**
   * 时间日期间隔
   * @class DateBetween
   */
  var DateBetween =
  /*#__PURE__*/
  function () {
    /**
     * 构造函数
     * @param {Date} start 开始时间
     * @param {Date} end 结束时间
     */
    function DateBetween(start, end) {
      classCallCheck(this, DateBetween);

      /**
       * @field start 开始时间
       */
      this.start = start;
      /**
       * @field end 结束时间
       */

      this.end = end;
    }
    /**
     * 获取毫秒差值
     * @returns {Number} 毫秒差值
     */


    createClass(DateBetween, [{
      key: "milliSecond",
      value: function milliSecond() {
        return this.end.getTime() - this.start.getTime();
      }
      /**
       * 获取秒差值
       * @returns {Number} 秒差值
       */

    }, {
      key: "second",
      value: function second() {
        return Math.floor(this.milliSecond() / 1000);
      }
      /**
       * 获取分钟差值
       * @returns {Number} 分钟差值
       */

    }, {
      key: "minute",
      value: function minute() {
        return Math.floor(this.second() / 60);
      }
      /**
       * 获取小时差值
       * @returns {Number} 小时差值
       */

    }, {
      key: "hour",
      value: function hour() {
        return Math.floor(this.minute() / 60);
      }
      /**
       * 获取天数差值
       * @returns {Number} 天数差值
       */

    }, {
      key: "day",
      value: function day() {
        return Math.floor(this.hour() / 24);
      }
      /**
       * 获取月份差值
       * 注: 此处获取的差值是按月计算的，即 2018-12-31 => 2019-01-01 也被认为相差一个月
       * @returns {Number} 月份差值
       */

    }, {
      key: "month",
      value: function month() {
        var year = this.year();
        var month = this.end.getMonth() - this.start.getMonth();
        return year * 12 + month;
      }
      /**
       * 获取年份差值
       * 注: 此处获取的差值是按年计算的，即 2018-12-31 => 2019-01-01 也被认为相差一年
       * @returns {Number} 年份差值
       */

    }, {
      key: "year",
      value: function year() {
        return this.end.getFullYear() - this.start.getFullYear();
      }
    }]);

    return DateBetween;
  }();
  /**
   * 获取两个时间的差值
   * @param {Date} start 开始时间
   * @param {Date} end 结束时间
   * @returns {DateBetween} 差值对象
   */

  function dateBetween(start, end) {
    return new DateBetween(start, end);
  }

  /**
   * 将指定函数包装为只调用一次
   * @param {Function} fn 需要包装的函数
   * @returns {Function} 包装后的函数
   */
  var onec = function onec(fn) {
    var flag = true;
    var res;
    return function () {
      if (flag === false) {
        return res;
      }

      flag = false;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return res = fn.call.apply(fn, [this].concat(args));
    };
  };

  /**
   * 包装一个函数为指定参数只执行一次的函数
   * @param {Function} fn 需要包装的函数
   * @param {Function} paramConverter 参数转换的函数，参数为需要包装函数的参数
   * @returns {Function} 需要被包装的函数
   */
  var onecOfSameParam = function onecOfSameParam(fn) {
    var paramConverter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return JSON.stringify(args);
    };
    var paramMap = new Map();
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var key = paramConverter.apply(void 0, args);
      var old = paramMap.get(key);

      if (old !== undefined) {
        return old;
      }

      var res = fn.call.apply(fn, [this].concat(args));

      if (res instanceof Promise) {
        return res.then(function (res) {
          paramMap.set(key, res);
          return res;
        });
      }

      paramMap.set(key, res);
      return res;
    };
  };

  /**
   * 返回合理参数本身的函数
   * 1. 如果没有参数则返回 undefined
   * 2. 如果只有一个参数则返回参数本身
   * 3. 如果有两个以上的参数则返回参数列表
   * @param {...Object} args 任何对象
   * @returns {undefined|Object|Array.<Object>} 传入的参数
   */
  function returnReasonableItself() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var len = args.length;

    if (len === 0) {
      return;
    }

    if (len === 1) {
      return args[0];
    }

    return args;
  }

  /**
   * 从数组中移除指定的元素
   * 注: 时间复杂度为 1~3On
   * @param {Array} arr 需要被过滤的数组
   * @param {Array} deleteItems 要过滤的元素数组
   * @param {Function} [kFn=returnItself] 每个元素的唯一键函数
   */

  function filterItems(arr, deleteItems) {
    var kFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : returnItself;
    // @ts-ignore
    var kSet = new Set(deleteItems.map(kFn));
    return arr.filter(function (v) {
      return !kSet.has(kFn(v));
    });
  }

  /**
   * 数组之间的差异结果类
   * @class ArrayDiff
   */

  var ArrayDiff =
  /**
   * 构造函数
   * @param {Array} left 第一个数组独有的元素列表
   * @param {Array} right 第二个数组独有的元素列表
   * @param {Array} common 两个数组共有的元素列表
   */
  function ArrayDiff(left, right, common) {
    classCallCheck(this, ArrayDiff);

    /**
     * @field 第一个数组独有的元素列表
     */
    this.left = left;
    /**
     * @field 第二个数组独有的元素列表
     */

    this.right = right;
    /**
     * @field 两个数组共有的元素列表
     */

    this.common = common;
  };
  /**
   * 比较两个数组的差异
   * @param {Array} thanArr 第一个数组
   * @param {Array} thatArr 第二个数组
   * @param {Function} [kFn=returnItself] 每个元素的唯一键函数
   * @returns {ArrayDiff} 比较的差异结果
   */

  function arrayDiffBy(thanArr, thatArr) {
    var kFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : returnItself;
    // @ts-ignore
    var kThanSet = new Set(thanArr.map(kFn)); // @ts-ignore

    var kThatSet = new Set(thatArr.map(kFn));
    var left = thanArr.filter(function (v) {
      return !kThatSet.has(kFn(v));
    });
    var right = thatArr.filter(function (v) {
      return !kThanSet.has(kFn(v));
    }); // @ts-ignore

    var kLeftSet = new Set(left.map(kFn));
    var common = thanArr.filter(function (v) {
      return !kLeftSet.has(kFn(v));
    });
    return new ArrayDiff(left, right, common);
  }

  var _marked =
  /*#__PURE__*/
  regenerator.mark(autoIncrementGenerator);
  /**
   * 使用 Generator 实现一个从 0 开始的自增序列
   */

  function autoIncrementGenerator() {
    var i;
    return regenerator.wrap(function autoIncrementGenerator$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            i = 0;

          case 1:
            _context.next = 3;
            return i;

          case 3:
            i++;
            _context.next = 1;
            break;

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }
  /**
   * 包装 {@link autoIncrementGenerator} 为只能调用一次的函数
   */


  var generator = onec(autoIncrementGenerator);
  /**
   * 获取自增长序列的最新值
   * @returns {Number} 最新值
   */

  function autoIncrement() {
    return generator().next().value;
  }

  /**
   * 转换基类
   */

  var IConverter =
  /*#__PURE__*/
  function () {
    function IConverter() {
      classCallCheck(this, IConverter);
    }

    createClass(IConverter, [{
      key: "from",

      /**
       * 将字符串解析为字符串列表
       *
       * @param {String} str 字符串
       * @return {Array.<String>} 字符串列表
       * @abstract
       */
      value: function from(str) {
        throw new Error('子类必须重写 from 函数');
      }
      /**
       * 将字符串列表构造为字符串
       *
       * @param {Array.<String>} list 字符串列表
       * @return {String} 字符串
       * @abstract
       */

    }, {
      key: "to",
      value: function to(list) {
        throw new Error('子类必须重写 to 函数');
      }
    }]);

    return IConverter;
  }();
  /**
   * 驼峰风格解析
   */

  var CamelOrPascalFrom =
  /*#__PURE__*/
  function (_IConverter) {
    inherits(CamelOrPascalFrom, _IConverter);

    function CamelOrPascalFrom() {
      classCallCheck(this, CamelOrPascalFrom);

      return possibleConstructorReturn(this, getPrototypeOf(CamelOrPascalFrom).apply(this, arguments));
    }

    createClass(CamelOrPascalFrom, [{
      key: "from",

      /**
       * 将字符串解析为字符串列表
       *
       * @param {String} str 字符串
       * @return {Array.<String>} 字符串列表
       * @override
       */
      value: function from(str) {
        var result = [];
        var len = str.length;
        var old = 0;

        for (var i = 0; i < len; i++) {
          var c = str.charAt(i);

          if (c >= 'A' && c <= 'Z') {
            if (i !== 0) {
              result.push(str.substring(old, i));
            }

            old = i;
          }
        }

        if (old !== str.length) {
          result.push(str.substring(old, str.length));
        }

        return result;
      }
    }]);

    return CamelOrPascalFrom;
  }(IConverter);
  /**
   * 小写开头的驼峰转换器
   *
   */

  var CamelConverter =
  /*#__PURE__*/
  function (_CamelOrPascalFrom) {
    inherits(CamelConverter, _CamelOrPascalFrom);

    function CamelConverter() {
      classCallCheck(this, CamelConverter);

      return possibleConstructorReturn(this, getPrototypeOf(CamelConverter).apply(this, arguments));
    }

    createClass(CamelConverter, [{
      key: "to",

      /**
       * 将字符串列表构造为字符串
       *
       * @param {Array.<String>} list 字符串列表
       * @return {String} 字符串
       * @override
       */
      value: function to(list) {
        var str = list.map(function (s) {
          return s.substring(0, 1).toUpperCase() + s.substring(1);
        }).join();
        return str.substring(0, 1).toLowerCase() + str.substring(1);
      }
    }]);

    return CamelConverter;
  }(CamelOrPascalFrom);
  /**
   * 大写开头的驼峰转换器
   */

  var PascalConverter =
  /*#__PURE__*/
  function (_CamelOrPascalFrom2) {
    inherits(PascalConverter, _CamelOrPascalFrom2);

    function PascalConverter() {
      classCallCheck(this, PascalConverter);

      return possibleConstructorReturn(this, getPrototypeOf(PascalConverter).apply(this, arguments));
    }

    createClass(PascalConverter, [{
      key: "to",

      /**
       * 将字符串列表构造为字符串
       *
       * @param {Array.<String>} list 字符串列表
       * @return {String} 字符串
       * @override
       */
      value: function to(list) {
        return list.map(function (s) {
          return s.substring(0, 1).toUpperCase() + s.substring(1);
        }).join();
      }
    }]);

    return PascalConverter;
  }(CamelOrPascalFrom);
  /**
   * 下划线风格解析
   */

  var SnakeOrScreamingSnakeFrom =
  /*#__PURE__*/
  function (_IConverter2) {
    inherits(SnakeOrScreamingSnakeFrom, _IConverter2);

    function SnakeOrScreamingSnakeFrom() {
      classCallCheck(this, SnakeOrScreamingSnakeFrom);

      return possibleConstructorReturn(this, getPrototypeOf(SnakeOrScreamingSnakeFrom).apply(this, arguments));
    }

    createClass(SnakeOrScreamingSnakeFrom, [{
      key: "from",

      /**
       * 将字符串解析为字符串列表
       *
       * @param {String} str 字符串
       * @return {Array.<String>} 字符串列表
       * @override
       */
      value: function from(str) {
        return str.split('_');
      }
    }]);

    return SnakeOrScreamingSnakeFrom;
  }(IConverter);
  /**
   * 小写下划线的转换器
   */

  var SnakeConverter =
  /*#__PURE__*/
  function (_SnakeOrScreamingSnak) {
    inherits(SnakeConverter, _SnakeOrScreamingSnak);

    function SnakeConverter() {
      classCallCheck(this, SnakeConverter);

      return possibleConstructorReturn(this, getPrototypeOf(SnakeConverter).apply(this, arguments));
    }

    createClass(SnakeConverter, [{
      key: "to",

      /**
       * 将字符串列表构造为字符串
       *
       * @param {Array.<String>} list 字符串列表
       * @return {String} 字符串
       * @override
       */
      value: function to(list) {
        return list.map(function (s) {
          return s.toLowerCase();
        }).join('_');
      }
    }]);

    return SnakeConverter;
  }(SnakeOrScreamingSnakeFrom);
  /**
   * 大写下划线的转换器
   */

  var ScreamingSnakeConverter =
  /*#__PURE__*/
  function (_SnakeOrScreamingSnak2) {
    inherits(ScreamingSnakeConverter, _SnakeOrScreamingSnak2);

    function ScreamingSnakeConverter() {
      classCallCheck(this, ScreamingSnakeConverter);

      return possibleConstructorReturn(this, getPrototypeOf(ScreamingSnakeConverter).apply(this, arguments));
    }

    createClass(ScreamingSnakeConverter, [{
      key: "to",

      /**
       * 将字符串列表构造为字符串
       *
       * @param {Array.<String>} list 字符串列表
       * @return {String} 字符串
       * @override
       */
      value: function to(list) {
        return list.map(function (s) {
          return s.toUpperCase();
        }).join('_');
      }
    }]);

    return ScreamingSnakeConverter;
  }(SnakeOrScreamingSnakeFrom);
  /**
   * @enum {Symbol} 字符串风格常量对象
   */

  var stringStyleType = {
    /**
     * 小写驼峰
     */
    Camel: Symbol(1),

    /**
     * 大写驼峰
     */
    Pascal: Symbol(2),

    /**
     * 小写下划线
     */
    Snake: Symbol(3),

    /**
     * 大写下划线
     */
    ScreamingSnake: Symbol(4)
    /**
     * 转换器工厂
     */

  };

  var ConverterFactory =
  /*#__PURE__*/
  function () {
    function ConverterFactory() {
      classCallCheck(this, ConverterFactory);
    }

    createClass(ConverterFactory, null, [{
      key: "getInstance",

      /**
       * 获取一个转换器实例
       *
       * @param {Symbol} styleType 转换风格，使用了 {@link stringStyleType} 定义的常量对象
       * @return {IConverter} 转换器对象
       * @throws 如果获取未定义过的转换器，则会抛出异常
       */
      value: function getInstance(styleType) {
        switch (styleType) {
          case stringStyleType.Camel:
            return new CamelConverter();

          case stringStyleType.Pascal:
            return new PascalConverter();

          case stringStyleType.Snake:
            return new SnakeConverter();

          case stringStyleType.ScreamingSnake:
            return new ScreamingSnakeConverter();

          default:
            throw new Error('No corresponding converter found');
        }
      }
    }]);

    return ConverterFactory;
  }();
  /**
   * 字符串风格转换器
   * 请不要直接使用构造函数创建，而是用 {@link StringStyleUtil.getConverter} 来获得一个转换器
   * @private
   */


  var StringStyleConverter =
  /*#__PURE__*/
  function () {
    /**
     * 构造一个字符串任意风格转换器
     * @param {Symbol} from 转换字符串的风格
     * @param {Symbol} to 需要转换的风格
     * @private
     */
    function StringStyleConverter(from, to) {
      classCallCheck(this, StringStyleConverter);

      /**
       * @field 解析字符串风格的转换器
       * @type {IConverter}
       * @private
       */
      this.fromConverter = ConverterFactory.getInstance(from);
      /**
       * @field 构造字符串风格的转换器
       * @type {IConverter}
       * @private
       */

      this.toConverter = ConverterFactory.getInstance(to);
    }
    /**
     * 转换字符串的风格
     *
     * @param {String} str 要转换的字符串
     * @return {String} 转换得到的字符串
     */


    createClass(StringStyleConverter, [{
      key: "convert",
      value: function convert(str) {
        if (str === undefined || str === null || str.length === 0) {
          return str;
        }

        return this.toConverter.to(this.fromConverter.from(str));
      }
    }]);

    return StringStyleConverter;
  }();
  /**
   * 包装获取字符串风格转换器
   * 此处采用了单例模式，每种转换器只会有一个
   *
   * @param {stringStyleType} from 解析风格
   * @param {stringStyleType} to 转换风格
   * @return {StringStyleConverter} 转换器的实例
   */

  var _getConverter = onecOfSameParam(
  /**
   * @param {stringStyleType} from 解析风格
   * @param {stringStyleType} to 转换风格
   * @return {StringStyleConverter} 转换器的实例
   */
  function (from, to) {
    return new StringStyleConverter(from, to);
  },
  /**
   * 根据参数生成唯一标识
   * @param {stringStyleType} from 解析风格
   * @param {stringStyleType} to 转换风格
   * @return {String} 唯一参数标识字符串
   */
  function (from, to) {
    return from.toString() + to.toString();
  });
  /**
   * 字符串风格转换工具类
   */


  var StringStyleUtil =
  /*#__PURE__*/
  function () {
    function StringStyleUtil() {
      classCallCheck(this, StringStyleUtil);
    }

    createClass(StringStyleUtil, null, [{
      key: "getConverter",

      /**
       * 获取一个转换器的实例
       * 该函数获取的转换器可以任意复用，请优先使用函数
       * @param {stringStyleType} from 解析风格
       * @param {stringStyleType} to 转换风格
       * @return {StringStyleConverter} 转换器的实例
       */
      value: function getConverter(from, to) {
        return _getConverter(from, to);
      }
      /**
       * 直接转换字符串的风格
       * 请优先使用可以复用的 {@link StringStyleUtil.getConverter} 函数
       * @param {stringStyleType} from 解析风格
       * @param {stringStyleType} to 转换风格
       * @param {String} str 要转换的字符串
       * @return {String} 转换得到的字符串
       */

    }, {
      key: "convert",
      value: function convert(from, to, str) {
        return StringStyleUtil.getConverter(from, to).convert(str);
      }
    }]);

    return StringStyleUtil;
  }();

  /**
   * 递归使对象不可变
   * @param {Object} obj 任何非空对象
   * @returns {Object} 新的不可变对象
   */
  function deepFreeze(obj) {
    if (obj === undefined || obj === null) {
      return;
    } // 数组和对象分别处理


    if (obj instanceof Array) {
      obj.forEach(function (v) {
        if (_typeof_1(v) === 'object') {
          deepFreeze(v);
        }
      });
    } else if (obj instanceof Object) {
      Object.values(obj).forEach(function (v) {
        if (_typeof_1(v) === 'object') {
          deepFreeze(v);
        }
      });
    }

    return Object.freeze(obj);
  }

  /**
   * 包装对象，使其成为可以任意深度调用而不会出现 undefined 调用的问题
   * 注意: 该函数不能进行递归调用（{@link JSON.stringfy}），一定会造成堆栈溢出的问题（RangeError: Maximum call stack size exceeded）
   * @param {Object} object 任意一个 Object 对象
   * @returns {Object} 包装后的对象
   */
  function deepProxy(object) {
    var handler = {
      get: function get(target, k) {
        Reflect.set(target, k, Reflect.has(target, k) ? Reflect.get(target, k) : {});
        var v = Reflect.get(target, k);

        if (_typeof_1(v) === 'object') {
          return new Proxy(v, handler);
        }

        return v;
      }
    };
    return new Proxy(object, handler);
  }

  /**
   * 将函数包装为柯里化函数
   * 注: 该函数模仿了 Lodash 的 curry 函数
   * @param {Function} fn 需要包装的函数
   * @param  {...any} args 应用的部分参数
   * @returns {Function} 包装后的函数
   */
  var curry = function curry(fn) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var realArgs = args.filter(function (arg) {
      return arg !== curry._;
    });

    if (realArgs.length >= fn.length) {
      return fn.apply(void 0, toConsumableArray(realArgs));
    }

    function innerFn() {
      for (var _len2 = arguments.length, otherArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        otherArgs[_key2] = arguments[_key2];
      }

      // 记录需要移除补到前面的参数
      var removeIndexSet = new Set();
      var i = 0;
      var newArgs = args.map(function (arg) {
        if (arg !== curry._ || otherArgs[i] === undefined || otherArgs[i] === curry._) {
          return arg;
        }

        removeIndexSet.add(i); // 每次补偿前面的 curry._ 参数计数器 +1

        return otherArgs[i++];
      });
      var newOtherArgs = otherArgs.filter(function (_v, i) {
        return !removeIndexSet.has(i);
      });
      return curry.apply(void 0, [fn].concat(toConsumableArray(newArgs), toConsumableArray(newOtherArgs)));
    } // 自定义 toString 函数便于调试


    innerFn.toString = function () {
      return "name: ".concat(fn.name, ", args: [").concat(args.map(function (o) {
        return o.toString();
      }).join(', '), "]");
    };

    innerFn._curry = true;
    return innerFn;
  };
  /**
   * 柯里化的占位符，需要应用后面的参数时使用
   * 例如 {@link curry(fn)(curry._, 1)} 意味着函数 fn 的第二个参数将被确定为 1
   */

  curry._ = Symbol('_');

  /**
   * 快速根据指定函数对数组进行排序
   * 注: 使用递归实现，对于超大数组（其实前端的数组不可能特别大吧？#笑）可能造成堆栈溢出
   * @param {Array} arr 需要排序的数组
   * @param {Function} [kFn=returnItself] 对数组中每个元素都产生可比较的值的函数，默认返回自身进行比较
   * @returns {Array} 排序后的新数组
   */

  function sortBy(arr) {
    var kFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : returnItself;

    // 边界条件，如果传入数组的值
    if (arr.length <= 1) {
      return arr;
    } // 根据中间值对数组分治为两个数组


    var medianIndex = Math.floor(arr.length / 2);
    var newArr = arr.slice();
    var median = newArr.splice(medianIndex, 1)[0];
    var medianValue = kFn(median);
    var map = groupBy(newArr, function (item) {
      return kFn(item) < medianValue;
    }); // 对两个数组分别进行排序

    return [].concat(toConsumableArray(sortBy(map.get(true) || [], kFn)), [median], toConsumableArray(sortBy(map.get(false) || [], kFn)));
  }

  /**
   * 日期格式化器
   * 包含格式化为字符串和解析字符串为日期的函数
   */

  var DateFormatter =
  /*#__PURE__*/
  function () {
    /**
     * 构造函数
     * @param {String} fmt 日期时间格式
     */
    function DateFormatter(fmt) {
      classCallCheck(this, DateFormatter);

      /**
       * @field 日期时间格式
       */
      this.fmt = fmt;
    }
    /**
     * 格式化
     * @param {Date} date 需要格式化的日期
     * @returns {String} 格式化的字符串
     */


    createClass(DateFormatter, [{
      key: "format",
      value: function format(date) {
        return dateFormat(date, this.fmt);
      }
      /**
       * 解析
       * @param {String} str 字符串
       * @returns {Date} 解析得到的日期
       */

    }, {
      key: "parse",
      value: function parse(str) {
        return dateParse(str, this.fmt);
      }
      /**
       * 将日期时间字符串转换为前端指定格式的字符串
       * 主要适用场景是前端接收到后端的日期时间一般是一个字符串，然而需要自定义格式的时候还必须先创建 {@link Date} 对象才能格式化，略微繁琐，故使用该函数
       * @param {String} str 字符串
       * @param {String} [parseFmt=undefined] 解析的日期时间格式。默认直接使用 {@link new Date()} 创建
       * @returns {String} 转换后得到的字符串
       */

    }, {
      key: "strFormat",
      value: function strFormat(str, parseFmt) {
        var date = parseFmt ? dateParse(str, parseFmt) : new Date(str);
        return dateFormat(date, this.fmt);
      }
    }]);

    return DateFormatter;
  }();
  /**
   * 日期格式化器
   */

  DateFormatter.dateFormatter = new DateFormatter('yyyy-MM-dd');
  /**
   * 时间格式化器
   */

  DateFormatter.timeFormatter = new DateFormatter('hh:mm:ss');
  /**
   * 日期时间格式化器
   */

  DateFormatter.dateTimeFormatter = new DateFormatter('yyyy-MM-dd hh:mm:ss');

  /**
   * 连接两个函数并自动柯里化
   * @param {Function} fn1 第一个函数
   * @param {Function} fn2 第二个函数
   * @returns {Function} 连接后的函数
   */

  var _compose = function _compose(fn1, fn2) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var res = curry.apply(void 0, [fn1].concat(args)); // 如果这个函数的参数不足，则返回它
      // @ts-ignore

      if (res instanceof Function && res._curry === true) {
        return _compose(res, fn2);
      }

      return curry(fn2, res);
    };
  };
  /**
   * 将多个函数组合起来
   * 前面函数的返回值将变成后面函数的第一个参数，如果到了最后一个函数执行完成，则直接返回
   * 该函数是自动柯里化，将对所有传入的函数进行柯里化处理
   * @param  {...Function} fns 多个需要连接函数
   * @returns {Function} 连接后的柯里化函数
   */


  var compose = function compose() {
    for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      fns[_key2] = arguments[_key2];
    }

    return (// TODO 反向连接就可以了?
      fns.reduceRight(function (fn1, fn2) {
        return _compose(fn2, fn1);
      })
    );
  };

  exports.DateFormatter = DateFormatter;
  exports.FetchLimiting = FetchLimiting;
  exports.StateMachine = StateMachine;
  exports.StringStyleUtil = StringStyleUtil;
  exports.appends = appends;
  exports.arrayDiffBy = arrayDiffBy;
  exports.arrayToMap = arrayToMap;
  exports.asIterator = asIterator;
  exports.asyncFlatMap = asyncFlatMap;
  exports.autoIncrement = autoIncrement;
  exports.blankToNull = blankToNull;
  exports.blankToNullField = blankToNullField;
  exports.compose = compose;
  exports.copyText = copyText;
  exports.createElByString = createElByString;
  exports.curry = curry;
  exports.dateBetween = dateBetween;
  exports.dateConstants = dateConstants;
  exports.dateEnhance = dateEnhance;
  exports.dateFormat = dateFormat;
  exports.dateParse = dateParse;
  exports.debounce = debounce;
  exports.deepFreeze = deepFreeze;
  exports.deepProxy = deepProxy;
  exports.deletes = deletes;
  exports.download = download;
  exports.downloadString = downloadString;
  exports.downloadUrl = downloadUrl;
  exports.emptyAllField = emptyAllField;
  exports.excludeFields = excludeFields;
  exports.fetchTimeout = fetchTimeout;
  exports.fill = fill;
  exports.filterItems = filterItems;
  exports.flatMap = flatMap;
  exports.formDataToArray = formDataToArray;
  exports.format = format;
  exports.getCookies = getCookies;
  exports.getCusorPostion = getCusorPostion;
  exports.getYearWeek = getYearWeek;
  exports.groupBy = groupBy;
  exports.insertText = insertText;
  exports.isEditable = isEditable;
  exports.isFloat = isFloat;
  exports.isNumber = isNumber;
  exports.isRange = isRange;
  exports.lastFocus = lastFocus;
  exports.loadResource = loadResource;
  exports.mapToObject = mapToObject;
  exports.objToFormData = objToFormData;
  exports.onec = onec;
  exports.onecOfSameParam = onecOfSameParam;
  exports.parseUrl = parseUrl;
  exports.randomInt = randomInt;
  exports.range = range;
  exports.readLocal = readLocal;
  exports.removeEl = removeEl;
  exports.removeText = removeText;
  exports.returnItself = returnItself;
  exports.returnReasonableItself = returnReasonableItself;
  exports.safeExec = safeExec;
  exports.setCusorPostion = setCusorPostion;
  exports.sets = sets;
  exports.singleModel = singleModel;
  exports.sortBy = sortBy;
  exports.spliceParams = spliceParams;
  exports.strToArrayBuffer = strToArrayBuffer;
  exports.strToDate = strToDate;
  exports.stringStyleType = stringStyleType;
  exports.throttle = throttle;
  exports.timing = timing;
  exports.toLowerCase = toLowerCase;
  exports.toObject = toObject;
  exports.toUpperCase = toUpperCase;
  exports.uniqueBy = uniqueBy;
  exports.wait = wait;
  exports.waitResource = waitResource;
  exports.watch = watch;
  exports.watchEventListener = watchEventListener;
  exports.watchObject = watchObject;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=rx-util.min.js.map
